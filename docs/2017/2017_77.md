# 从算法到训练，综述强化学习实现技巧与调试经验

选自 GitHub

**作者：WilliamFalcon **

**机器之心编译**

**参与：乾树、黄小天**

> 本文整理自 John Schulman 题为「深度强化学习研究的具体内容」的演讲，主要内容是作者在加州大学伯克利分校参加夏季深度强化学习训练营时写下的技巧。

GitHub 地址：https://github.com/williamFalcon/DeepRLHacks

## 调试新算法的技巧

1\. 通过低维状态空间环境的使用简化问题。

*   John 建议使用钟摆问题，因为它具有 2 维状态空间（摆角与速度）。

*   便于得到值函数的形式和算法应处的状态，以及它们随时间如何演化。

*   直观地了解为什么某些参数不起作用（也可以说，价值函数是否足够平滑等）

2. 为了测试你的算法是否合理，你要构造一个适用于该算法的问题。

*   例如：对于分层强化学习，你要构建一个它应该会学习的明显的分层结构的问题。

*   该问题可以简单测试出算法是否合理。

*   警告：不要使算法过度拟合你这个玩具问题（你要知道玩具问题并不具有实际意义）。

3\.  熟悉你知道的某些环境。

*   随着时间的推移，你将会知道训练应该花费多长时间。

*   知晓奖励信号的演化过程等。

*   允许你设置一个基准，以了解你过去试验的效果。

*   John 使用弹跳机器人，通过这个机器人他知道应该采取多快的学习速度，并且可以很容易地发现奇怪的行为。

## 调试新任务的技巧

1\.  简化任务

*   开始简化直到曙光降临。

*   方法 1 ：简化特征空间：

   ◦ 例如，如果你正在使用图像（巨大的维度空间）学习，那么可能先要手动处理图像特征。示例：如果你觉得你的函数正在尝试近似得到某个参数的位置，请使用 x，y 坐标位置作为步骤 1 的特征。

   ◦ 一旦前一步开始工作，将使问题更加复杂，直到你解决所有的问题。

*   方法 2：简化奖励函数。

   ◦ 这样你就可以快速地得到反馈，从而知道算法是否正确。

   ◦ 例如：当机器人击中目标时有奖励（+1）。这通常很难学习，因为在开始和奖励函数之间的不确定因素太多了。将问题重新定位为目标的距离，这将增加学习，并带来更快的迭代速度。

## **在强化学习中构建问题的技巧**

也许现在还不清楚这些特征是什么，奖励是什么，甚至它是否可行。

1. 第一步：可视化处理这个问题的随机策略。

*   看看它的效果。

*   如果随机策略奏效过，那么很有可能强化学习会得到预期的效果。

   ◦ 策略梯度会发现这种行为，并使其更有可能。

*   如果随机策略从未奏效，那么强化学习基本也不用考虑了。

2. 确保评论有用：

*   通过给个体同样的评论来测试你能否控制这个系统。

   ◦ 示例：自己查看预处理的图像，以确保没有删除必要的细节或某种程度上阻碍了算法。

3. 确保合理地缩放特征。

 经验法则：

   ◦ 评论：取特征均值为 0，标准差为 1。

   ◦ 奖励: 如果你能控制它，就把它放缩到一个合理的值。

       ◦ 对当前所有数据进行处理。

*   观测所有的评论和奖励，确保没有过度的异常值。

4. 每当你碰到一个新问题，都要找好出发点。

*   目前还不清楚哪种算法可行，因此有一组出发点（从其他方法）

   ◦ 交叉熵法

   ◦ 策略梯度法

   ◦ 某种 Q-learning 方法 (点击 OpenAI Baselines 或 RLLab 开始学习）

## 重现论文代码

依托论文来重现其中的实验结果有时（很多时候）很难。下面有一些技巧可能帮到你：

1\. 使用多于你当前所需的样本。

2\. 采用正确的策略，但这并非绝对。

*   循序渐进，一点一点的改进算法。

*   然后微调超参数使其具有泛化能力。

*   使用更大的批量可以使算法作用于所有数据。

   ◦ 如果批量太小，噪声会掩盖信号。

   ◦ 例如：TRPO，John 用的批量太小，只好设置时间步为 100k。

   ◦ DQN 的最佳超参数为：10k 时间步，1mm 帧置于 replay buffer。

## 训练指导手册

全面检查你的训练是否奏效。

1. 查看每个超参数的灵敏度

*   如果算法过于敏感，那么就是算法不够鲁棒，我们不应该满足于此。

*   有时一个莫名的变动会使算法奏效，但这并不具有泛化能力。

2. 监测优化过程中的指标是有益的。

*   变化值

*   观察价值函数是否精确。

   ◦ 预测是否有效？

   ◦ 预测的返回值正常吗？

   ◦ 更新范围有多大？

*   来自深度网络的标准诊断

3. 有一个连续的基准测试系统。

*   需要惩罚。

*   比较你尝试过的所有问题的性能。

   ◦ 有时，它对于一个问题有效，但对别的问题就错乱了。

   ◦ 容易过拟合某一个问题。

*   有一套你偶尔运行的基准测试系统。

4\. 误以为你的算法有效，但实际上看到的是随机噪音。

*   例子：7 个任务的 3 个算法图，看起来像 1 个算法，可能在适用于所有问题，但事实证明却是随机种子不同的相同算法罢了。

5. 尝试不同的随机种子！！

*   多次运行并取平均值。

*   在多个种子上运行多个任务。

   ◦ 否则，算法可能会过拟合。

6. 算法大可不必修改。

*   大多数技巧实际上是以某种方式规范化特征或改进你的优化过程。

*   很多技巧也有同样的效果…所以你可以删除其中的一些，简化你的算法（非常关键）。

7. 简化你的算法

*   泛化能力更佳

8. 实验过程自动化

*   不要花一整天的时间看你的代码输出结果。

*   在云服务上进行实验并分析结果。

*   使用框架跟踪实验和结果：

   ◦ 大多使用 iPython notebooks。

   ◦ 似乎不需要将结果存进数据库。

## 通用的训练策略

1. 白化（Whiten）和标准化数据（一开始就对所有数据进行处理）。

*   评论：

    ◦ 通过计算运行平均值和标准差来计算。然后对所有数据进行 z 变换。处理所有数据（不仅仅是最近的数据）。

    ◦ 评论所有看到的数据（不只是最近的数据）

        ◦ 至少它会随着时间的推移而缩小，它随时间变化的很快。

        ◦ 如果你不断改变目标，可能会误导优化器。

        ◦ 缩放（用新数据）意味着你的优化器可能不认识这些数据，并且性能将大打折扣。

*   奖励：

   ◦ 缩放但不转移数据。

       ◦ 影响代理发展的意愿。

       ◦ 会改变问题（换句话说，你想要代理生存多久）。

*   规范目标：

   ◦ 与奖励相同。

*   PCA 白化？

   ◦ 有用

   ◦ 首先看看它是否真的有助于神经网络。

   ◦ 过度的缩放（-1000,1000）或（-0.001,0.001）肯定会使学习缓慢。

2. 表示折扣因子的参数。

*   确定你的信用分配。

*   例如：如果因子是 0.99，那么你就会忘记 100 步之前发生了什么... 这意味着你目光短浅。

   ◦ 最好去关注它如何应用于实时数据。

       ◦ 为了更好的感受，在强化学习中我们通常将时间离散化。

       ◦ 这 100 步是实际时间的 3 秒吗？

       ◦ 那段时间里会发生什么？

*   如果 TD 方法用于估计值函数 fx 的策略梯度，则 gamma 可以接近 1（如 0.999）

   ◦ 算法变得非常稳定。

3. 这个问题可以在离散化的层次上真正解决。

*   例如：在游戏中，如果你正在做跳帧。

   ◦ 作为一个人，你是否能控制它？

   ◦ 看看随机探索的样子

       ◦ 离散化决定你的布朗运动走多远。

       ◦ 如果连续做许多动作，那么算法就倾向于进一步探索。

       ◦ 用一种有效方式来将你的时间离散化。

4. 密切关注每段训练返回值。

*   不只是看看最大值和最小值。

   ◦ 最好的回馈是你的策略可以得到很好的磨合。

   ◦ 你的策略总是按预期来的吗？？

*   看 episode 长度（有时比它的奖励更有用）。

   ◦ 如果在游戏中你每次都输，所以你可能永远赢不了，但是…episode 长度可以告诉你，如果你输的速度较慢。

   ◦ 你可能在开始时看到 episode 长度的改进，但不一定是奖励。

## 策略梯度方法调整

1. 密切关注熵

*   动作空间的熵

   ◦ 更关注状态空间中的熵，但没有很好的计算方法。

*   如果梯度下降得太快，那么策略就会变得确定而不再探索。

*   如果梯度不下降，那么策略就不正确，因为它实际上是随机的。

*   可以修复：

   ◦  KL 惩罚

       ◦ 防止梯度下降过快。

   ◦ 为熵加权重。

*   如何测量熵。

   ◦ 对于大多数策略，可以解析地计算熵。

       ◦ 如果熵连续，通常是高斯的，所以可以计算微分熵。

2. KL 散度

*   从 KL 散度看更新的大小。

*   例子:如果 KL 是 0.1，更新过小。如果是 10 更新又过大。

3. 以方差为基准。

*   看看价值函数是否真的是一个好的预测器或奖励。

   ◦ 如果方差为负可能是过拟合或噪声过大。

       ◦ 可能需要调整超参数。

4. 初始化策略

*   非常重要（比在监督学习还重要）。

*   最终层输出 0 或极小值以最大化熵

    ◦ 在开始时最大限度地随机探索

## Q-学习策略

1\. 谨慎使用 replay buffer 的内存。

*   你可能需要一个巨大的缓冲区，因此需要相应地修改代码。

2\. 指定一份学习率表。

3\. 如果收敛缓慢或有一个缓慢的启动期

*   耐心等待，DQN 收敛速度极慢。

******本文为机器之心编译，***转载请联系本公众号获得授权******。***

✄------------------------------------------------

**加入机器之心（全职记者/实习生）：hr@jiqizhixin.com**

**投稿或寻求报道：content@jiqizhixin.com**

**广告&商务合作：bd@jiqizhixin.com**